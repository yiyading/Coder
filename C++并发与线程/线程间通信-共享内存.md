
共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。

进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc()分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

特别提醒：共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问，例如信号量。

头文件：#include<sys/sem.h>

int shmget(key_t key, size_t size, int shmflg)：创建共享内存
> 获取与key(键)关联的共享内存标识符。<br>
> 返回一个共享内存标识符(shm_id)。<br>
> 其余函数通过共享内存标识符操作共享内存。<br>

void *shmat(int shm_id, const void *shm_addr, int shmflg)：内存段映射到用户进程空间
> 第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间<br>
> shmat将shm_id指向的共享内存链接入进程；返回指向共享内存第一个字节的指针(shmaddr)。<br>

int shmdt(const void *shmaddr)：将共享内存从用户进程空间剥离（并不是删除）
> shmaddr是shmat返回的只想共享内存第一个字节的指针。

int shmctl(int shm_id, int command, struct shmid_ds *buf)：操作共享内存

优点：我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。

缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。

shmdata.h
```cpp
  
#ifndef _SHMDATA_H_HEADER
#define _SHMDATA_H_HEADER

#define TEXT_SZ 2048

struct shared_use_st
{
	int written; // 作为一个标志，非0：表示可读；0：表示可写
	char text[TEXT_SZ];
};

#endif
```

shmread.c
```cpp
// 创建共享内存，并读取其中信息
#include <stddef.h>
#include <sys/shm.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include "shmdata.h"
 
int main(int argc, char **argv)
{
    void *shm = NULL;
    struct shared_use_st *shared; // 指向shm
    int shmid; // 共享内存标识符
 
    // 创建共享内存
    shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT);
    if (shmid == -1)
    {
        fprintf(stderr, "shmat failed\n");
        exit(EXIT_FAILURE);
    }
 
    // 将共享内存连接到当前进程的地址空间
    shm = shmat(shmid, 0, 0);
    if (shm == (void *)-1)
    {
        fprintf(stderr, "shmat failed\n");
        exit(EXIT_FAILURE);
    }
 
    printf("\nMemory attached at %X\n", (int)shm);
 
    // 设置共享内存
    shared = (struct shared_use_st*)shm; // 注意：shm有点类似通过 malloc() 获取到的内存，所以这里需要做个类型强制转换
    shared->written = 0;
    while (1) // 读取共享内存中的数据
    {
        // 没有进程向内存写数据，有数据可读取
        if (shared->written == 1)
        {
            printf("You wrote: %s", shared->text);
            sleep(1);
 
            // 读取完数据，设置written使共享内存段可写
            shared->written = 0;
 
            // 输入了 end，退出循环（程序）
            if (strncmp(shared->text, "end", 3) == 0)
            {
                break;	// break跳出while和for循环
            }
        }
        else // 有其他进程在写数据，不能读取数据
        {
            sleep(1);
        }
    }
 
    // 把共享内存从当前进程中分离
    if (shmdt(shm) == -1)
    {
        fprintf(stderr, "shmdt failed\n");
        exit(EXIT_FAILURE);
    }
 
    // 删除共享内存
    if (shmctl(shmid, IPC_RMID, 0) == -1)
    {
        fprintf(stderr, "shmctl(IPC_RMID) failed\n");
        exit(EXIT_FAILURE);
    }
 
    exit(EXIT_SUCCESS);
}
```

shmwrite.c
```cpp
#include<unistd.h>
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<sys/shm.h>
#include"shmdata.h"

int main(int argc, char **argv){
	void *shm = NULL;
	struct shared_use_st *shared=NULL;
	char buffer[BUFSIZ + 1];	// 用于保存输入的文本
	int shmid;

	//创建共享内存
	shmid = shmget((key_t)1234, sizeof(struct shared_use_st), 0666|IPC_CREAT);
	if(shmid == -1){
		fprintf(stderr, "shmget failed\n");
		exit(EXIT_FAILURE);
	}

	shm=shmat(shmid, (void *)0, 0);
	if(shm ==(void *)-1){
		fprintf(stderr, "shmat failed\n");
		exit(EXIT_FAILURE);
	}
	printf("Memory attched at %x\n", (int)shm);

	// 设置共享内存
	shared=(struct shared_use_st *)shm;
	while(1){	// 向内存中写数据
		// 数据还没有被读取，则等待数据被读取，不能向共享内存中写入文本
		while(shared->written == 1){
			sleep(1);
			printf("Waiting...\n");
		}

		// 向共享内存中写入数据
		printf("enter some text: ");
		fgets(buffer, BUFSIZ, stdin);
		strncpy(shared->text, buffer, TEXT_SZ); // 将buffer中前TEXT_SZ个字符复制到share->text中

		// 写完数据，设置written使共享内存段可读
		shared->written = 1;
	
		// 输入了end，退出循环(程序)
		if(strncmp(buffer, "end", 3) == 0)
			break;
	}
	
	// 把共享内存从当前进程中分离
	if(shmdt(shm) == -1){
		fprintf(stderr, "shmdt failed\n");
		exit(EXIT_FAILURE);
	}

	sleep(2);
	exit(EXIT_SUCCESS);
}
```