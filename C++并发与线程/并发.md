# 并发：std::atomic原子操作

C++中对共享数据的存取在并发条件下可能会引起data race的undifined行为。需限制并发程序以某种特定的顺序执行

1. 使用mutex保护共享数据，原子操作。
2. 非原子操作：某个线程可能看见的是一个其它线程操作未完成的数据。

## bool原子化

### std::atomin_flag

std::atomic_flag：有两个状态的bool原子类型，必须被ATOMIC_FLAG_INIT初始化为clear。

atomic_flag初始化后只有三个操作：test_and_set,clear,析构，均是原子化操作。
1. atomic_flag::test_and_set检查flag是否被设置，若被设置直接返回true，若没有设置则设置flag为true后再返回false
2. atomic_clear()清除flag标志即flag=false。

不支持拷贝、赋值等操作，这和所有atomic类型一样，因为两个原子类型之间操作不能保证原子化。

atomic_flag的可操作性不强导致其应用局限性，还不如atomic<bool>。

```c++
#include <iostream>       // std::cout
#include <atomic>         // std::atomic_flag
#include <thread>         // std::thread
#include <vector>         // std::vector
#include <sstream>        // std::stringstream
 
std::atomic_flag lock_stream = ATOMIC_FLAG_INIT;    // flag处于clear状态，没有被设置过
std::stringstream stream;
 
void append_number(int x)
{
    while (lock_stream.test_and_set()) 
    {
        // 检查并设置是个原子操作，如以前没有设置过则退出循环，
    }
        //每个线程都等待前面一个线程将lock_stream状态清除后跳出循环

    stream << "thread #" << x << '\n'; 
    lock_stream.clear();
}

int main (){ 
    std::vector<std::thread> threads; 
    for (int i = 0; i < 10; ++i) 
    {
        std::cout << "i: " << i << std::endl;
        threads.push_back(std::thread(append_number, i+1)); 
    }

    // for (auto& th : threads) 
    //     th.join(); 
        
    for(int i=0; i<10; i++)
    {
        threads[i].detach();
    }

    std::cout << stream.str(); 
    return 0;
}
```

### std::atomic<T>

atomic<T>模板类，生成一个T类型的原子对象，并提供了系列原子操作函数。

```c++
// atomic::compare_exchange_weak example:
#include <iostream>       // std::cout
#include <atomic>         // std::atomic
#include <thread>         // std::thread
#include <vector>         // std::vector

// a simple global linked list:
struct Node
{
    int value;
    Node* next;
};
std::atomic<Node*> list_head (nullptr);

void append (int val)
{     // append an element to the list head
  Node* newNode = new Node {val, list_head};

  // next is the same as: list_head = newNode, but in a thread-safe way:
  while (!list_head.compare_exchange_weak(newNode->next,newNode)) {}
  
  // (with newNode->next updated accordingly if some other thread just appended another node)
}
int main ()
{
  // spawn 10 threads to fill the linked list:
  std::vector<std::thread> threads;
  for (int i=0; i<10; ++i) 
  threads.push_back(std::thread(append, i));

  for (auto& th : threads) 
    th.join();

  // print contents:
  for (Node* it = list_head; it!=nullptr; it=it->next)
    std::cout << ' ' << it->value;
  std::cout << '\n';
  
  // cleanup:
  Node* it; 
  while (it=list_head)
  {
      list_head=it->next; 
      delete it;
  }
  return 0;
}
```