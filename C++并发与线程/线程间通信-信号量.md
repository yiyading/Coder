# 线程间通信
## 信号量：一次只允许一个线程访问临界资源。

信号量是一种外部资源的标识，不具有数据交换功能，通过控制其他资源实现线程间通信。

线程对其操作都是原子的。并且只允许对他进行等待。

信号量只有两种操作：P和V
0. sv代表信号量的值，通常只取0和1(二进制信号量)
1. P(sv)：如果sv > 0，怎sv--，线程访问其管理的临界资源；如果sv = 0，线程挂起。
2. V(sv)：如果其他进程因等待sv而挂起，让线程恢复运行，否则sv++。

头文件：#include<sys/sem.h>

int semget(key_t _key, int _nsems, int _semflg)：创建一个信号量集，或取得一个已存在的信号量集。
> 获取与key(键)关联的信号量集标识。<br>
> 返回一个信号量集标识符(semid)。<br>
> 其余函数通过信号量集标识符操作信号量集。

int semop(int semid ,struct sembuf *_sops ,size_t _nsops)：改变信号量的值
> semop()在semid标识的信号量集上，对编号为_sops->sem_num的信号量进行_sops->semop操作，_nsops指出将要操作的信号量的数目

int semctl(int semid, int semnum, int cmd, ... )：删除信号量或初始化信号量
> semctl()在semid标识的信号量集上，或者该集合的第semnum个信号量上执行cmd指定的控制命令。(信号量集合索引起始于零)

信号量使用完要删除，否则会一直存在。

ipcs -s可以查看当前信号量的使用情况。

```c
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<sys/sem.h>

// semctl()函数的常用第四个参数
#if 1
union semun
{
	int val;
	struct semid_ds *buf;
	unsigned short *array;
};
#endif

static int sem_id = 0;
static int set_semvalue();
static void del_semvalue();
static int semaphore_p();
static int semaphore_v();

int main(int argc, char *argv[])
{
	char message = 'X';
	int i = 0;

	// 创建信号量
	sem_id = semget((key_t)6666, 1, 0666|IPC_CREAT);

	if(argc > 1){
		if(!set_semvalue()){
			fprintf(stderr, "Failed to initialize semaphore\n");
			exit(EXIT_FAILURE);
		}
		
		// 设置要输出到屏幕的信息，即其参数的第一个字符
		message = argv[1][0] ;
		sleep(2);
	}

	for(i=0; i<10; ++i){
		// 进入临界区
		if(!semaphore_p())
			exit(EXIT_FAILURE);

		// 向屏幕中输出数据
		printf("%c", message);

		// 清理缓冲区，然后休眠数秒
		fflush(stdout);
		sleep(rand() % 3);

		// 离开临界区前再一次向屏幕输出数据
		printf("%c", message);
		fflush(stdout);

		// 离开临界区，休眠随机时间后继续循环
		if(!semaphore_v())
			exit(EXIT_FAILURE);
		
		sleep(rand() % 2);
	}

	sleep(10);
	printf("\n%d - finishen\n",getpid());

	if(argc > 1){
		// 如果程序是第一次被调用，则在退出前删除信号量
		sleep(3);
		del_semvalue();
	}
	exit(EXIT_SUCCESS);
}

static int set_semvalue(){
	// 使用信号量前必须初始化信号量
	union semun sem_union;

	sem_union.val = 1;
	if(semctl(sem_id, 0, SETVAL, sem_union) == -1)
		return 0;

	return 1;
}

static void del_semvalue(){
	// 删除信号量
	union semun sem_union;

	if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1)
		fprintf(stderr, "Failed to delete semaphore\n");
}

static int semaphore_p(){
	// 对信号量做减1操作，即等待P(sv)
	struct sembuf sem_b;
	sem_b.sem_num = 0;
	sem_b.sem_op = -1; // P()
	sem_b.sem_flg = SEM_UNDO;

	if(semop(sem_id, &sem_b, 1) == -1){
		fprintf(stderr, "semaphore_p failed\n");
		return 0;
	}

	return 1;
}

static int semaphore_v(){
	// 释放操作，使信号量变成可用，即发送信号V(sv)
	struct sembuf sem_b;
	sem_b.sem_num = 0;
	sem_b.sem_op = 1; // V()
	sem_b.sem_flg = SEM_UNDO;

	if(semop(sem_id, &sem_b, 1) == -1){
		fprintf(stderr, "semaphore_v failed\n");
		return 0;
	}

	return 1;
}
```