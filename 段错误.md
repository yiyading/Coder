## Segmentation fault 

所谓的段错误就是指访问的内存超过了系统所给这个程序的内存空间，也就是当程序试图访问不被允许访问的内存区域（比如，尝试写一块属于操作系统的内存），或以错误的类型访问内存区域（比如，尝试写一块只读内存）。

## SIGSEGV信号

1. SIGSEGV是在访问内存时发生的错误，它属于内存管理的范畴。
2. SIGSEGV是一个用户态的概念，是操作系统在用户态程序错误访问内存时所做出的处理。
3. 当用户态程序访问（访问表示读、写或执行）不允许访问的内存时，产生SIGSEGV。
4. 当用户态程序以错误的方式访问允许访问的内存时，产生SIGSEGV。


## SIGSEGB的产生情况

指针越界：SIGSEGV在很多时候是由于指针越界引起的，但并不是所有的指针越界都会引发SIGSEGV。一个越界的指针，如果不引用它，是不会引起SIGSEGV的。而即使引用了一个越界的指针，也不一定引起SIGSEGV。

1. 错误的访问类型（访问只读区域）。
2. 访问不属于进程地址空间的内存。
3. 访问了不存在的内存。
4. 内存越界，数组越界，变量类型不一致等。
5. 试图把一个整数按照字符串的方式输出。
6. 栈溢出了，有时SIGSEGV，有时却啥都没发生。

## 析构函数的调用——第一种情况

1. 对象生命周期结束，被销毁时调用析构函数。
2. 主动调用delete，调用析构函数。
3. 对象i是对象o的成员，对象o的系够函数被调用时，i调用系够函数。

## 析构函数的调用——第二种情况 

1. new的对象，即使离开作用域也会一直存在，必须主动调用delete。否则只有在结束程序时候才会执行析够函数。
> new和malloc都是在堆上分配空间。<br>
> 存放在栈上的局部变量如果使用new开辟空间，在离开这个局部变量所在的函数后，就无法再访问该空间，会造成内存泄漏。

