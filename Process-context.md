
在LIUNX完全注释中有这么一段话：当一个进程在执行时，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。**当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够得到切换时的状态执行下去**。

在LINUX中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时，内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中断服务结束时能恢复被中断进程的执行。

> 进程数据结构：Linux中，进程和线程到了内核中，都叫任务（task）；没一个task都一个数据接口task_struct用来保存task的状态。<br>
> Linux内核中有一个task链表，将task_struct链接起来。<br>

换句话说：**进程上下文就是表示进程信息的一系列东西，包括各种变量、寄存器以及进程的运行的环境。这样，当进程被切换后，下次再切换回来继续执行，能够知道原来的状态**。<br>

同理，中断上下文就是中断发生时，原来的进程执行被打断，那么就要把原来的那些变量保存下来，以便中断完成后再恢复。<br>

处理器总处于以下三种状态之一：<br>
> 1、内核态，运行于进程上下文，内核代表进程运行于内核空间；<br>
> 2、内核态，运行于中断上下文，内核代表硬件运行于内核空间；<br>
> 3、用户态，运行于用户空间。<br>

[内核空间和用户空间的区别]()<br>

# 进程上下文(Process context)
在Linux中，用户程序装入系统形成一个进程的实质是系统为用户程序提供一个完整的**运行环境**。进程的运行环境是由它的**程序代码**和**程序运行所需要的数据结构**以及**硬件环境**组成的。<br>

进程的运行环境主要包括：<br>
> 1.进程空间中的代码和数据、各种数据结构、进程堆栈和共享内存区等。<br>
> 2.环境变量：提供进程运行所需的环境信息。<br>
> 3.系统数据：进程空间中的对进程进行管理和控制所需的信息，包括进程任务结构体以及内核堆栈等。<br>
> 4.进程访问设备或者文件时的权限。<br>
> 5.各种硬件寄存器。<br>
> 6.地址转换信息。<br>

从以上组成情况可以看到，进程的运行环境是**动态变化**的，尤其是硬件寄存器的值以及进程控制信息是随着进程的运行而不断变化的。在Linux中把系统提供给进程的的处于动态变化的运行环境总和称为**进程上下文**。<br>

系统中的每一个进程都有自己的上下文。一个正在使用处理器运行的进程称为当前进程(**current**)。当前进程因时间片用完或者因等待某个事件而阻塞时，进程调度需要把处理器的使用权从当前进程交给另一个进程，这个过程叫做**进程切换**。此时，被调用进程成为当前进程。在进程切换时系统要把当前进程的上下文保存在指定的内存区域（该进程的任务状态段TSS中），然后把下一个使用处理器运行的进程的上下文设置成当前进程的上下文。当一个进程经过调度再次使用CPU运行时，系统要恢复该进程保存的上下文。所以，**进程的切换也就是上下文切换**。<br>

在系统内核为用户进程服务时，通常是进程通过系统调用执行内核代码，这时进程的执行状态由用户态转换为内核态。但是，此时内核的运行是为用户进程服务，也可以说内核在代替当前进程执行某种服务功能。在这种情况下，内核的运行仍是进程运行的一部分，所以说这时内核是运行在进程上下文中。内核运行在进程上下文中时可以访问和修改进程的系统数据。此外，若内核运行在进程上下文中需要等待资源和设备时，系统可以阻塞当前进程。<br>

# 中断上下文
硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。中断时，内核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一般不会阻塞。<br>


# 两者的区别
进程上下文保存的是进程运行时，进程所需要的各种环境参数。<br>
中断上写文保存的是发生中断时，硬件传来的参数和其他环境。<br>

上下文本质上是一种数据结构，用来保存相关信息。<br>
